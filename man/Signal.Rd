% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genericStrategy.R, R/rules_indicators.R,
%   R/signal_classes.R
\name{addIndicators}
\alias{addIndicators}
\alias{addIndicator}
\alias{addRule}
\alias{addRuleConstraint}
\alias{getIndicators}
\alias{getRules}
\alias{getRuleConstraints}
\alias{getRule}
\alias{getSignals}
\alias{removeRule}
\alias{removeIndicator}
\alias{addIndicators.Strategy}
\alias{addRule.Strategy}
\alias{addRuleConstraint.Strategy}
\alias{getIndicators.Strategy}
\alias{getRules.Strategy}
\alias{getRuleConstraints.Strategy}
\alias{getRule.Strategy}
\alias{getSignals.Strategy}
\alias{Signal}
\alias{Indicator}
\alias{Rule}
\alias{RuleConstraint}
\title{Add multiple indicators to strategy}
\usage{
addIndicators(this, ...)

addIndicator(this, ...)

addRule(this, ...)

addRuleConstraint(this, ...)

getIndicators(this)

getRules(this, pathwise)

getRuleConstraints(this)

getRule(this, name)

getSignals(this)

removeRule(this, name)

removeIndicator(this, name)

\method{addIndicators}{Strategy}(this, ...)

\method{addRule}{Strategy}(this, ...)

\method{addRuleConstraint}{Strategy}(this, ...)

\method{getIndicators}{Strategy}(this)

\method{getRules}{Strategy}(this, pathwise)

\method{getRuleConstraints}{Strategy}(this)

\method{getRule}{Strategy}(this, name)

\method{getSignals}{Strategy}(this)

Signal(expr, name, lookback = 0, args = list(), ...)

Indicator(lookforward = Inf, history = TRUE, vars = NULL, ...)

Rule(
  type = "enter",
  block,
  pathwise = FALSE,
  position = NULL,
  position_const = NULL,
  price = NULL,
  on_success = NULL,
  ...
)

RuleConstraint(rules = NULL, rule_type = NULL, ...)
}
\arguments{
\item{this}{Strategy}

\item{...}{args passed to Signal}

\item{pathwise}{logical, whether expr will be calculated on each iteration or not. In other words if pathwise is FALSE
then expr will be calculated once with indicators, it should return logical vector, then in each iteration element of this
vector will be used, if pathwise is TRUE then expr will be calculated at each iteration, it should return logical scalar.}

\item{name}{character, name of signal}

\item{expr}{expression}

\item{lookback}{numeric / expression, how many periods is needed for calculation signal}

\item{args}{list, parameters for a signal}

\item{lookforward}{numeric / expression. If it is numeric then after that number of points all indicators will be recalculated.
If it is expression then it should return logical. It will indicate recalculate indicators or not.}

\item{history}{logical, whether it expressed as matrix of previous and future values or expressed as statistic that recalculated
when lookforward triggers}

\item{vars}{character vector, which names should exported from expr}

\item{type}{character, 'exit' or 'enter'}

\item{block}{character, it is needed for combining bunch of rules in one namespace. For example
rule with type exit will be triggered only if it has the same block variable as entry rule.}

\item{position}{numeric vector, what position for each instrument should be at each iteration when model in position}

\item{position_const}{numeric vector, what position for each instrument should be at entry to position}

\item{price}{numeric vector, what prices should be used for change position}

\item{rules}{character vector, names of rules}

\item{rule_type}{character, type is 'exit' or 'enter'. If it is not missed it will be applied to all rules in this group,
rules argument will be ignored.}
}
\value{
list of inforamation

list of information

list of information

list of information

list of information
}
\description{
These indicators will be calculated each time when spread updates coefficients
indicators must return data.frame or matrix or array

Base class for indicators, rules and more

Indicators serves for calculating rules

This class serves for describing moments when model should open position or exit from it.

This class is needed to add constraints for expr for rules. It can be treated as operator AND for expr of rules.
}
